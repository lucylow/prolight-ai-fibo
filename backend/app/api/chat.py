"""
Chat API - Natural language chat endpoint with streaming support.
"""

from fastapi import APIRouter, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.responses import StreamingResponse
from typing import List
import json
import logging

from app.models.schemas import ChatRequest, ChatResponse, ChatMessage, ChatStreamChunk
from app.services.chat_engine import ChatEngine

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/chat", tags=["Chat"])

# Global chat engine instance
chat_engine = ChatEngine()


# ============================================================================
# REST Endpoint
# ============================================================================

@router.post("", response_model=ChatResponse)
async def chat_endpoint(request: ChatRequest):
    """
    Chat endpoint - handles natural language conversations.
    
    Supports:
    - Intent detection
    - Entity extraction
    - Context-aware responses with RAG
    - Conversation memory
    """
    try:
        if not request.messages:
            raise HTTPException(status_code=400, detail="At least one message is required")
        
        # Get last user message
        last_message = None
        for msg in reversed(request.messages):
            if msg.role == "user":
                last_message = msg.content
                break
        
        if not last_message:
            raise HTTPException(status_code=400, detail="At least one user message is required")
        
        # Get response from chat engine
        response = await chat_engine.get_response(
            conversation_id=request.conversation_id,
            user_text=last_message
        )
        
        return ChatResponse(
            reply=response.get("reply", ""),
            intent=response.get("intent"),
            entities=response.get("entities", {}),
            followups=None  # Could be generated by LLM
        )
        
    except Exception as e:
        logger.error(f"Error in chat endpoint: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# Streaming Endpoint (SSE)
# ============================================================================

@router.post("/stream")
async def chat_stream_endpoint(request: ChatRequest):
    """
    Streaming chat endpoint using Server-Sent Events (SSE).
    
    Returns a streaming response with text chunks as they are generated.
    """
    try:
        if not request.messages:
            raise HTTPException(status_code=400, detail="At least one message is required")
        
        # Get last user message
        last_message = None
        for msg in reversed(request.messages):
            if msg.role == "user":
                last_message = msg.content
                break
        
        if not last_message:
            raise HTTPException(status_code=400, detail="At least one user message is required")
        
        async def generate():
            """Generator for SSE streaming."""
            try:
                async for chunk in chat_engine.stream_response(
                    conversation_id=request.conversation_id,
                    user_text=last_message
                ):
                    # Format as SSE
                    chunk_json = json.dumps(chunk)
                    yield f"data: {chunk_json}\n\n"
            except Exception as e:
                logger.error(f"Error in stream: {e}")
                error_chunk = {
                    "type": "error",
                    "error": str(e)
                }
                yield f"data: {json.dumps(error_chunk)}\n\n"
        
        return StreamingResponse(
            generate(),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "X-Accel-Buffering": "no",  # Disable nginx buffering
            }
        )
        
    except Exception as e:
        logger.error(f"Error in stream endpoint: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# WebSocket Endpoint
# ============================================================================

class ConnectionManager:
    """Manages WebSocket connections."""
    
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        """Accept a WebSocket connection."""
        await websocket.accept()
        self.active_connections.append(websocket)
        logger.info(f"WebSocket connected. Total connections: {len(self.active_connections)}")
    
    def disconnect(self, websocket: WebSocket):
        """Remove a WebSocket connection."""
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
        logger.info(f"WebSocket disconnected. Total connections: {len(self.active_connections)}")
    
    async def send_json(self, websocket: WebSocket, data: dict):
        """Send JSON data to a WebSocket."""
        try:
            await websocket.send_json(data)
        except Exception as e:
            logger.error(f"Error sending WebSocket message: {e}")
            self.disconnect(websocket)


manager = ConnectionManager()


@router.websocket("/ws/{conversation_id}")
async def websocket_chat(websocket: WebSocket, conversation_id: str):
    """
    WebSocket endpoint for streaming chat.
    
    Expected message format:
    {
        "text": "user message here"
    }
    
    Response format:
    {
        "type": "delta" | "intent" | "done" | "error",
        "delta": "...",  // for type="delta"
        "intent": "...", // for type="intent"
        "entities": {...}, // for type="intent"
        "full_response": "...", // for type="done"
        "error": "..." // for type="error"
    }
    """
    await manager.connect(websocket)
    
    try:
        while True:
            # Receive message from client
            data = await websocket.receive_json()
            user_text = data.get("text", "")
            
            if not user_text:
                await manager.send_json(websocket, {
                    "type": "error",
                    "error": "Empty message"
                })
                continue
            
            # Stream response
            async for chunk in chat_engine.stream_response(
                conversation_id=conversation_id,
                user_text=user_text
            ):
                await manager.send_json(websocket, chunk)
                
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        logger.info(f"WebSocket disconnected for conversation {conversation_id}")
    except Exception as e:
        logger.error(f"Error in WebSocket chat: {e}")
        try:
            await manager.send_json(websocket, {
                "type": "error",
                "error": str(e)
            })
        except:
            pass
        manager.disconnect(websocket)

